{"_id":{"$oid":"5b47240a74c36974d9e84add"},"title":"NodeJS CRUD using MongoDB","category":"nodejs","content":"<h2 id=\"h2-step-by-step-building-node-js-based-rest-api-to-perform-crud-operations-on-mongodb-\"><a name=\"Step by Step building Node.js based REST API to perform CRUD operations on MongoDB.\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Step by Step building Node.js based REST API to perform CRUD operations on MongoDB.</h2><p>Node.js is one of the greatest platform to create backend of the application. Does not matter whether you are creating a mobile app for iOS or Single Page Web application using Angular, you will need a backend for the application. Usually you perform databases operations, authentications, authorizations, logging etc. in the backend. I am sure, you have heard about the term MEAN stack. If you have not, MEAN stands for MongoDB, Express JS, Angular, and Node.js.</p>\n<p>For detailed example and follwing details, please follow the below link;</p>\n<p><a href=\"https://www.callicoder.com/node-js-express-mongodb-restful-crud-api-tutorial/\">NodeJS and MongoDB CRUD operations tutorial</a></p>\n<ul>\n<li>Creating the Application</li><li>Install dependencies</li><li>Setting up the web server</li><li>Configuring and Connecting to the database</li><li>Defining Routes using Express</li><li>Testing APIs</li></ul>\n<p><a href=\"https://www.callicoder.com/node-js-express-mongodb-restful-crud-api-tutorial/\">NodeJS and MongoDB CRUD operations tutorial</a></p>\n","description":"Node.js is one of the greatest platform to create backend of the application. This tutorial helps implement basic crud using mnodejs and mongoDB.","publisherId":"5b44b4e949e8b918bc53766e","createdOn":{"$date":{"$numberLong":"1531388938130"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b482b8674c36974d9e84aed"},"title":"NodeJS with Oracle Database","category":"nodejs","content":"<p>With the increasing popularity of NodeJS,Oracle has released the npm module for Oracle database.</p>\n<p>Now we can connect the Oracle database from nodejs application using <strong>node-oracledb</strong> module.</p>\n<p>The details can be found in the below url.</p>\n<p><a href=\"https://github.com/oracle/node-oracledb\">https://github.com/oracle/node-oracledb</a></p>\n","description":"Connecting NodeJS with the Oracle database","publisherId":"5b4828df74c36974d9e84aec","createdOn":{"$date":{"$numberLong":"1531456390882"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b48757574c36974d9e84afa"},"title":"Oracle JET Component Exchange","category":"js","content":"","description":"Oracle's internal portal for exchanging the UI components to download and share with Oracle JET community. \n\nhttp://exchange.oraclecorp.com/ui/index.html?root=home\n","publisherId":"5b4874bc74c36974d9e84af9","createdOn":{"$date":{"$numberLong":"1531475317711"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4c1d6002ebbd0e1c186463"},"title":"JavaScript and Oracle","category":"nodejs","content":"","description":"JSAO.IO (JavaScript and Oracle) is a blog created by Dan McGhan which has multiple tutorials for Oracle technologies using NodeJS and Javascript. Few tutorials are about creating rest api using NodeJS and Oracle database. \n\nhttps://jsao.io/\n\n","publisherId":"5b4874bc74c36974d9e84af9","createdOn":{"$date":{"$numberLong":"1531714912026"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4c2ed402ebbd0e1c186466"},"title":"Oracle JET Home page","category":"js","content":"<p><a href=\"http://jet.us.oracle.com/5.1.0/\">http://jet.us.oracle.com/5.1.0/</a></p>\n","description":"Click on this to access home page of Oracle JET \nhttp://jet.us.oracle.com/5.1.0/","publisherId":"5b45e3ec6c55380d79c2c32e","createdOn":{"$date":{"$numberLong":"1531719380371"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4da03a0a5b34117e10259a"},"title":"JAVA vs NodeJS","category":"nodejs","content":"","description":"Node.js vs. Java: An epic battle for developer mind share\n\nhttps://www.infoworld.com/article/2883328/node-js/java-vs-nodejs-an-epic-battle-for-developer-mindshare.html","publisherId":"5b4874bc74c36974d9e84af9","createdOn":{"$date":{"$numberLong":"1531813946718"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4f27faf53e9076f99b5004"},"title":"Immutable.js ","category":"js","content":"<p><a href=\"https://facebook.github.io/immutable-js/\" title=\"immutable.js\">immutable.js</a> how it makes life easier when dealing with below kind of complex state data.</p>\n<p><strong>Want to update/replace fragment of my JSON object with other part:</strong></p>\n<pre><code class=\"lang-json\">{ \n    &quot;id&quot;: &quot;A&quot;,\n    &quot;children&quot;: [\n        {\n            &quot;id&quot;: &quot;B&quot;,\n            &quot;children&quot;: [\n\n            ]\n        },\n        {\n            &quot;id&quot;: &quot;C&quot;,\n            &quot;children&quot;: [\n\n            ]\n        },\n        {\n            &quot;id&quot;: &quot;D&quot;,\n            &quot;children&quot;: [\n                {\n                    &quot;id&quot;: &quot;E&quot;,\n                    &quot;children&quot;: [\n                        {\n                            &quot;id&quot;: &quot;F&quot;, // THIS NODE WILL BE UPDATED\n                            &quot;children&quot;: [\n\n                            ]\n                        }\n                    ]\n                },\n                {\n                    &quot;id&quot;: &quot;G&quot;,\n                    &quot;children&quot;: [\n\n                    ]\n                }\n            ]\n        }\n    ]\n}\n</code></pre>\n<p>setIn() of immutable.js is a straightforward solution that will get the job done.</p>\n<p>Please take a look below library:<br><a href=\"https://www.npmjs.com/package/immutable\" title=\"Immutable npm\">Immutable.js</a></p>\n","description":"immutable.js how it makes life easier when dealing with complex state data in Javascript.","publisherId":"5b4c1c6502ebbd0e1c186462","createdOn":{"$date":{"$numberLong":"1531914234824"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4720f174c36974d9e84adc"},"title":"JS  component and web component checklist","category":"js","content":"<h3 id=\"h3-javascript-re-usable-component-check-list\"><a name=\"Javascript Re-usable component Check-list\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Javascript Re-usable component Check-list</h3><h3 id=\"h3-table-of-contents\"><a name=\"Table Of Contents\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Table Of Contents</h3><ul>\n<li>Creating re-usable components in JET - the right way</li><li>Writing Sustainable code</li><li>Adhering to Web component standards</li><li>Say No to JQuery</li><li>Scope for improvement</li></ul>\n<h3 id=\"h3--creating-re-usable-component-in-jet\"><a name=\"## Creating re-usable component in JET\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>## Creating re-usable component in JET</h3><ul>\n<li>Often, UI developers follow web component standard when developing a re-usable component.</li><li>The meaning of re-usable component is absolute, de􀂡nite and cannot be altered at the will of a developer. </li><li>A re-usable component always has a de􀂡nition with the following attributes.</li><li>Autonomous functionality - Component should be independent of business logic</li><li>Should accept input data</li><li>Should give output as event dispatchers</li><li>Should be configurable</li><li>Should have encapsulated DOM or Shadow DOM</li><li>Should have default configuration</li><li>Should support two way data binding</li><li>Should be scoped and have isolated scope</li><li>Should Have a cutom element name</li><li>Should enable transclusion</li><li>Should have private methods only</li><li>Should avoid using JQuery</li></ul>\n<h3 id=\"h3-web-component-standard\"><a name=\"Web Component Standard\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Web Component Standard</h3><p>This is a standard set of speci􀂡cations to develop re-usable components. Crucial specs are as follows</p>\n<ul>\n<li>Shadow DOM</li><li>Custom Elements</li><li>HTML templates</li><li>Do not use third party libraries - No JQuery</li><li>These speci􀂡cations are derived from the web component standard community forum.</li><li>It is evolving and future of UI is web components. Angular and React strictly follow the standard and aspire to be there once w3c approves the drafted standards.</li></ul>\n","description":"A checklist to create re-usable JS component. Feature the web component standards.","publisherId":"5b44b4e949e8b918bc53766e","createdOn":{"$date":{"$numberLong":"1531388145808"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4d98bb0a5b34117e102597"},"title":"Node JS Tips & Tricks","category":"js","content":"<p><strong>1. Immediately invoked function expressions</strong><br>An immediately invoked function expression (IIFE) is a function that’s executed as soon as it’s created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:<br>(function() {<br>     // all your code here<br>     // …<br>})();<br>The first pair of parentheses function(){…} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression. An IIFE can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.<br><strong>2. Closures</strong><br>A closure in JavaScript is an inner function that has access to its outer function’s scope, even after the outer function has returned control. A closure makes the variables of the inner function private. A simple example of a closure is shown below:<br>var count = (function () {<br>     var _counter = 0;<br>     return function () {return _counter += 1;}<br>})();</p>\n<p>count();<br>count();<br>count();</p>\n<p>// the counter is now 3<br>The variable count is assigned an outer function. The outer function runs only once, which sets the counter to zero and returns an inner function. The _counter variable can be accessed only by the inner function, which makes it behave like a private variable.<br><strong>3. Prototypes</strong><br>Every JavaScript function has a prototype property that is used to attach properties and methods. This property is not enumerable. It allows the developer to attach methods or member functions to its objects. JavaScript supports inheritance only through the prototype property. In case of an inherited object, the prototype property points to the object’s parent. A common approach to attach methods to a function is to use prototypes as shown below:</p>\n<p>function Rectangle(x, y) {<br>     this._length = x;<br>     this._breadth = y;<br>}</p>\n<p>Rectangle.prototype.getDimensions = function () {<br>     return { length : this._length, breadth : this._breadth };<br>};</p>\n<p>Rectangle.prototype.setDimensions = function (len, bred) {<br>     this._length = len;<br>     this._breadth = bred;<br>};<br><strong>4. Private properties, using closures</strong><br>JavaScript lets you define private properties by using the underscore prefix as shown in the above example. However, this does not prevent a user from directly accessing or modifying a property that is supposed to be private.<br>Defining private properties using closures will help you solve this problem. The member functions that need access to private properties should be defined on the object itself. You can make private properties using closures as shown below:<br>function Rectangle(_length, _breadth) {</p>\n<pre><code> this.getDimensions = function () {\n return { length : _length, breadth : _breadth };\n };\n\n this.setDimension = function (len,bred) {\n _length = len;\n _breadth = bred\n };\n</code></pre><p>}<br><strong>5. The Module pattern</strong><br>The Module pattern is the most frequently used design pattern in JavaScript for achieving loosely coupled, well-structured code. It allows you to create public and private access levels. One way to achieve a Module pattern is shown below:<br>var Direction = (function() {<br>     var _direction = ‘forward’<br>     var changeDirection = function(d) {<br>          _direction = d;<br>     }</p>\n<pre><code> return {           setDirection: function(d) {\n      changeDirection(d);\n      console.log(_direction);\n      }\n };\n</code></pre><p>})();</p>\n<p>Direction.setDirection(‘backward’);     // Outputs: ‘backward’<br>console.log(Direction._direction);<br>The Revealing Module pattern is similar to the Module pattern wherein the variables and methods that need to be exposed are returned in an object literal. The above example can be written using the Revealing Module pattern as follows:<br>var Direction = (function() {<br>     var _direction = ‘forward’;<br>     var _privateChangeDirection = function(d) {<br>          _direction = d;<br>     }</p>\n<pre><code> return {\n      setDirection: _privateChangeDirection\n };\n</code></pre><p>})();<br><strong>6. Hoisting</strong><br>JavaScript moves variables and function declarations to the top of their scope before code execution. This is called hoisting. Regardless of where you place the declaration of functions and variables in your code, they are moved to the top of their scope by the interpreter. This may or may not be where you want them. If not, then your program will have errors.<br>Variable declarations are processed before any code is executed. Ironically, undeclared variables do not exist until they are assigned a value. This causes all undeclared variables to become global variables. Though function declarations are hoisted, function expressions are not hoisted. JavaScript has an order of priority while hoisting variables and functions.<br>The priority is given below from higher to lower:<br>•    Variable assignment<br>•    Function declaration<br>•    Variable declarations<br>To avoid bugs, you should declare your variables and functions at the beginning of every scope.<br><strong>7. Currying</strong><br>Currying is a method of making functions more flexible. With a curried function, you can pass all of the arguments that the function is expecting and get the result, or you can pass only a subset of arguments and receive a function back that waits for the rest of the arguments. A simple example of a curry is given below:<br>var myFirstCurry = function(word) {<br>     return function(user) {<br>            return [word , “, “ , user].join(“”);<br>     };<br>};</p>\n<p>var HelloUser = myFirstCurry(“Hello”);<br>HelloUser(“Rahul”); // Output: “Hello, Rahul”<br>The original curried function can be called directly by passing each of the parameters in a separate set of parentheses one after the other as shown below:<br>myFirstCurry(“Hey, wassup!”)(“Rahul”); // Output: “Hey, wassup!, Rahul”<br><strong>8. The apply, call, and bind methods</strong><br>It’s imperative for any JavaScript developer to understand the difference between the call, apply, and bind methods. The three functions are similar in that their first argument is always the “this” value, or context, that you want to give the function you are calling the method on.<br>Of the three, call is the easiest. It’s the same as invoking a function while specifying its context. Here’s an example:<br>var user = {<br>     name: “Rahul Mhatre”,<br>     whatIsYourName: function() {<br>     console.log(this.name);<br>     }<br>};</p>\n<p>user.whatIsYourName(); // Output: “Rahul Mhatre”,<br>var user2 = {<br>     name: “Neha Sampat”<br>};</p>\n<p>user.whatIsYourName.call(user2); // Output: “Neha Sampat”<br>apply is nearly the same as call. The only difference is that you pass arguments as an array and not separately. Arrays are easier to manipulate in JavaScript, opening a larger number of possibilities for working with functions. Here is an example using apply and call:<br>var user = {<br>     greet: “Hello!”,<br>     greetUser: function(userName) {<br>     console.log(this.greet + “ “ + userName);<br>     }<br>};</p>\n<p>var greet1 = {<br>     greet: “Hola”<br>};</p>\n<p>user.greetUser.call(greet1,”Rahul”) // Output: “Hola Rahul”<br>user.greetUser.apply(greet1,[“Rahul”]) // Output: “Hola Rahul”<br>The bind method allows you to pass arguments to a function without invoking it. A new function is returned with arguments bounded preceding any further arguments. Here is an example:<br>var user = {<br>     greet: “Hello!”,<br>     greetUser: function(userName) {<br>     console.log(this.greet + “ “ + userName);<br>     }<br>};</p>\n<p>var greetHola = user.greetUser.bind({greet: “Hola”});<br>var greetBonjour = user.greetUser.bind({greet: “Bonjour”});</p>\n<p>greetHola(“Rahul”) // Output: “Hola Rahul”<br>greetBonjour(“Rahul”) // Output: “Bonjour Rahul”<br><strong>9. Memoization</strong><br>Memoization is an optimization technique that speeds up function execution by storing results of expensive operations and returning the cached results when the same set of inputs occur again. JavaScript objects behave like associative arrays, making it easy to implement memoization in JavaScript. For example, we can convert a recursive factorial function into a memoized factorial function as shown below:<br>function memoizeFunction(func) {<br>     var cache = {};<br>     return function() {<br>          var key = arguments[0];<br>          if(cache[key]) {<br>          return cache[key];<br>          }<br>          else {<br>          var val = func.apply(this, arguments);<br>          cache[key] = val;<br>          return val;<br>          }<br>     };<br>}</p>\n<p>var fibonacci = memoizeFunction(function(n) {<br>     return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);<br>});<br><strong>10. Method overloading</strong><br>Method overloading allows multiple methods to have the same name but different arguments. The compiler or interpreter determines which function to call based on the number of arguments passed. Method overloading is not directly supported in JavaScript. But you can achieve something very much like it as shown below:<br>function overloadMethod(object, name, fn){<br>     if(!object._overload){<br>     object._overload = {};<br>     }</p>\n<pre><code> if(!object._overload[name]){\n object._overload[name] = {};\n }\n\n  if(!object._overload[name][fn.length]){\n</code></pre><p>object._overload[name][fn.length] = fn;<br>     }</p>\n<pre><code> object[name] = function() {\n      if(this._overload[name][arguments.length])\n      return this._overload[name][arguments.length].apply(this, arguments);\n };\n</code></pre><p>}</p>\n<p>function Students(){<br>    overloadMethod(this, “find”, function(){<br>          // Find a student by name<br>     });</p>\n<pre><code> overloadMethod(this, &quot;find&quot;, function(first, last){\n      // Find a student by first and last name\n });\n</code></pre><p>}</p>\n<p>var students = new Students();<br>students.find(); // Finds all<br>students.find(“Rahul”); // Finds students by name<br>students.find(“Rahul”, “Mhatre”); // Finds users by first and last name</p>\n<p>As one become well-versed with Node.js, you’ll notice there are many ways to solve almost every problem. But taking the right approach is critical. A wrong approach will result in multiple side effects like patchy or buggy applications or regressions that force you to rewrite the entire logic. On the flip side, the right approach will lay the foundation for a robust, efficient, and scalable application.</p>\n","description":"JavaScript can be a boon if used with care—or a bane if you are reckless. Following structured rules, design patterns, key concepts, and basic rules of thumb will help you choose the optimal approach to a problem. Which key concepts should Node.js programmers understand? Below I’ll share the 10 JavaScript concepts that I believe are most essential to writing efficient and scalable Node.js code.","publisherId":"5b4c6b5802ebbd0e1c18646d","createdOn":{"$date":{"$numberLong":"1531812027488"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4ea86970d2974b29af66e2"},"title":"Unit testing Node JS Applications","category":"nodejs","content":"<p>Unit testing has become an integral part of daily development process. It is an important phase of software development, as it is an attempt made towards keeping the code cleaner and making the product functionally better. Applications written in Node.js are no different. They would face the similar kind of issues that any other application would face, if they are deployed without testing them enough.</p>\n<p>Now some of you may have a question in your minds that what can you test in Node.js? Any server based application has business logic, data access logic and endpoints to interact with the clients. We need to test all of them as even a small change applied on any of this logic, sometimes impacts functionality of the application as a whole.</p>\n<h4 id=\"h4--strong-setting-up-node-js-testing-environment-strong-\"><a name=\"<strong>Setting up Node.js Testing Environment</strong>\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><strong>Setting up Node.js Testing Environment</strong></h4><p>Before we start writing unit tests, we need to have an environment ready to run the tests. To do so, we need to pick a test framework and set the environment for it.<br>We have a number of test frameworks available to test Node.js applications. One of the well-known frameworks amongst them is Mocha. It is a BDD (Behavior Driven Development) based test framework composed with a simple syntax. Like any other Node.js packages, Mocha is available on NPM. If it is installed globally, it can be used to run tests using command line from any location.</p>\n<blockquote>\n<p>npm install -g mocha</p>\n</blockquote>\n<h5 id=\"h5-a-basic-node-js-application\"><a name=\"A Basic Node.js Application\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>A Basic Node.js Application</h5><p>Let’s set up a basic Node.js application to test. The application would contain one page and an API. Both of these endpoints would be created using Express. Create a new folder on your system, add a new JavaScript file to this folder and name it server.js. Place the following code in this file:</p>\n<p><em>var app = require(‘express’)();</em></p>\n<p><em>app.get(‘/api/person’, function (request, response) {<br>    response.send({<br>        name:”Amit”,<br>        city:”Bangalore”,<br>        age:25<br>    });<br>});</em></p>\n<p>app.get(‘/‘, function (request, response) {<br>    response.sendFile(__dirname + ‘/index.html’);<br>});</p>\n<p>app.listen(3000, function () {<br>    cosole.log(“Server started on port 3000”);<br>});</p>\n<p>module.exports.server = app;</p>\n<p>To complete the sample, just install the Express package.</p>\n<p><strong>Note</strong>: Express.js is a light weight framework built on top of Node.js and it provides abstractions to make our job of working with HTTP easier. Express also provides a way to add middle-wares to the pipeline. These middle-wares can be used to perform tasks like authentication, logging, and any other pre or, post processing logic that has to be executed with every request.<br>Express.js can be installed into using NPM. Run the following command to install express.js:</p>\n<blockquote>\n<p>npm install express</p>\n</blockquote>\n<h5 id=\"h5-unit-testing-sample-using-mocha\"><a name=\"Unit Testing Sample using Mocha\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Unit Testing Sample using Mocha</h5><p>During testing, we compare the value of variables and check to see if they match the values of what we wrote in our original program. In other words, we need to verify that our code runs as expected. This is called as running an assertion. We need to use an assertion library along with Mocha to verify the correctness of our logic. The home page of the Mocha’s official site lists many assertion testing libraries like Chai, Expect and Should.js for many programming styles. Of these, we will use Node.js own built-in library assert for assertion. It can be installed using NPM.</p>\n<blockquote>\n<p>npm install assert —save-dev</p>\n</blockquote>\n<p>Add a new file to the folder and name it tests.js.<br>To begin with, let’s write a simple function and test it using Mocha. Add the following snippet to this file:</p>\n<p><em>var assert = require(‘assert’);</em></p>\n<p><em>describe(‘Sample unit tests’, function () {<br>    function add(x, y){<br>        return x+y;<br>    }<br>    it(‘should return 5’, function () {<br>        assert.equal(add(2,3), 5);<br>    });<br>});</em></p>\n<p>To run this test, open a command prompt, move to the location of this folder and run the following command:</p>\n<blockquote>\n<p>mocha tests.js</p>\n</blockquote>\n<p>The result of this command is the following:</p>\n<p><em>Sample unit tests<br>   v should return 5<br>1 passing (22ms)</em></p>\n<p>Let’s make the test fail. For this, change the value compared to 6 in the above assertion and run the test using the same command. Here’s the result:</p>\n<p><em>Sample unit tests<br>1)    Should return 5<br>0 passing (35ms)<br>1 failing<br>1)    Sample unit tests should return 5:</em></p>\n<p><em>AssertionError: 5 == 6<br> +expected – actual<br>-5<br>+6</em></p>\n<p>Now that you have some familiarity with Mocha and Assert, let’s write tests to assert the logic written in server.js file. As the logic in this file deals with HTTP requests and responses, we need a way to manually send requests and assert their responses. The package supertest provides us with a way to do this. Install it using the following NPM command:</p>\n<blockquote>\n<p>npm install supertest —save-dev</p>\n</blockquote>\n<p>Let’s get a reference of the object exposed by this library and invoke the server file to start the Node.js server.</p>\n<p><em>var request = require(‘supertest’);</em></p>\n<p><em>//inside describe block<br>var server;<br>beforeEach(function () {<br>  server = require(‘./server’).server;<br>});</em></p>\n<p>A request to home URL of the application returns an HTML file. We can assert this behavior by sending a request to the path and then check the type of response generated by the server. Following test asserts request to the home URL:</p>\n<p><em>it(‘should respond with an htmL file when root is requested’, function (done) {<br>  request(server)<br>    .get(‘/‘)<br>    .expect(200)<br>    .end(function (err, response) {<br>      assert.equal(response.header[‘content-type’], ‘text/html; charset=UTF-8’);<br>      done();<br>    });<br>});</em></p>\n<p>If you observe the above test carefully, you will see that it accepts a parameter (done) in the callback function of the test. The parameter indicates that it is an asynchronous test. It is a callback function that needs to be called upon completion of the test. As the test in above case can be said to be completed after the assertion is checked, we called the done function after the assertion.<br>Let’s check if the REST API /api/person returns the right result using the same procedure. Following is the test case:</p>\n<p><em>it(‘should respond with JSON data when API is called’, function (done) {<br>  request(server)<br>    .get(‘/api/person’)<br>    .expect(200)<br>    .end(function (err, response) {<br>      assert.equal(response.header[‘content-type’], ‘application/json; charset=utf-8’);<br>      assert.deepEqual(response.body, {<br>        name:”Amit”,<br>        city:”Bangalore”,<br>        age:25<br>      });<br>      done();<br>    });<br>});</em></p>\n<p>A request to any path other than these two should result a 404 from the server. We can check this condition too. Following is the test for this:</p>\n<p><em>it(‘should send 404 when a request is made to any other path’, function (done) {<br>  request(server)<br>    .get(‘/dummy/path’)<br>    .expect(404, done);<br>});</em></p>\n","description":"Unit testing has become an integral part of daily development process. It is an important phase of software development, as it is an attempt made towards keeping the code cleaner and making the product functionally better. Applications written in Node.js are no different. They would face the similar kind of issues that any other application would face, if they are deployed without testing them enough.\nWe have a number of test frameworks available to test Node.js applications. One of the well-known frameworks amongst them is Mocha. It is a BDD (Behavior Driven Development) based test framework composed with a simple syntax. Like any other Node.js packages, Mocha is available on NPM. If it is installed globally, it can be used to run tests using command line from any location.","publisherId":"5b4c6b5802ebbd0e1c18646d","createdOn":{"$date":{"$numberLong":"1531881577972"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4eb10770d2974b29af66e3"},"title":"Basic Authentication in Node JS","category":"nodejs","content":"<h4 id=\"h4-basic-authentication-implementation\"><a name=\"Basic Authentication Implementation\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Basic Authentication Implementation</h4><p><strong>Step 1:</strong> <strong>You can use any IDE of your choice</strong>. To implement this application, I will use the free Visual Studio Code. This is a new IDE used for developing and building modern Web and Cloud applications. To use Node.js built-in modules and other tools we need to use Node.js tools.</p>\n<p><strong>Step 2:</strong> Create a folder with the name <strong>VSCodeBasicAuthentication</strong> on your hard drive. This folder will be used as workspace for the application. Open Visual Studio Code IDE and open the folder from File &gt; Open Folder option. In this folder add a new folder of name <strong>Scripts</strong>.<br>To manage Node.js intelligence for the application, run the following command from the Node.js command prompt. Open the Node.js command prompt and navigate to the <strong>VSCodeBasicAuthentication</strong> folder.</p>\n<p><em>npm install -g tsd<br>tsd query node —action install</em></p>\n<p><strong>Step 3:</strong> In the Scripts folder, add a new file with the name app.js. In this file, we will create a Web Server using <strong>http</strong> module. The following code contains logic for basic authentication</p>\n<p><em>//1.<br>var http = require(‘http’);</em></p>\n<p><em>//2.<br>var credentials = {<br>    userName: “oracle”,<br>    password: “oracle1234”<br>};</em><br><em>var realm = ‘Basic Authentication’;</em></p>\n<p><em>//3.<br>function authenticationStatus(resp) {<br>    resp.writeHead(401, { ‘WWW-Authenticate’: ‘Basic realm=”‘ + realm + ‘“‘ });<br>    resp.end(‘Authorization is needed’);<br>};</em></p>\n<p>//4.<br><em>var server = http.createServer(function (request, response) {<br>    var authentication, loginInfo;</em></p>\n<p><em>//5.<br>    if (!request.headers.authorization) {<br>        authenticationStatus (response);<br>        return;<br>    }</em></p>\n<p><em>//6.<br>    authentication = request.headers.authorization.replace(/^Basic/, ‘’);</em></p>\n<p><em>//7.<br>    authentication = (new Buffer(authentication, ‘base64’)).toString(‘utf8’);</em></p>\n<p><em>//8.<br>    loginInfo = authentication.split(‘:’);</em></p>\n<p><em>//9.<br>    if (loginInfo[0] === credentials.userName &amp;&amp; loginInfo[1] === credentials.password) {<br>        response.end(‘Great You are Authenticated…’);<br>    }<br>    authenticationStatus (response);<br>});</em></p>\n<p><em>//10.<br>server.listen(5050);</em></p>\n<p>The above code contains specifications as explained in following points (Note: Comment number in the above code matches with the numbering given below)</p>\n<ol>\n<li><p>Create <strong>http</strong> server using http module. Here we are creating Web Server using code. This web server will be responsible for basic authentication.</p>\n</li><li><p>The JavaScript object for initializing the Credentials.</p>\n</li><li><p>The function authenticationStatus() is used to provide the authentication window to user when the web server url is entered in the browsers address bar.</p>\n</li><li><p>The Web Server is created with the <strong>requestlistener</strong> callback.</p>\n</li><li><p>This step is responsible for reading the authorization information from the header.</p>\n</li><li><p>This step is responsible for filtering the ‘Basic’ word from the <strong>authorization</strong> header.</p>\n</li><li><p>This step is used to decode the credential information from the header and retrieve the original values.</p>\n</li><li><p>The retrieved information is in the form of userName:password. This step splits the username and password.</p>\n</li><li><p>This step is used to validate the UserName and Password based on the values stored in the <strong>credentials</strong> JavaScript object. If this information is matched, then the <strong>Great You are Authenticated…</strong> message will be sent to the user.</p>\n</li><li><p>Start listening on port 5050.</p>\n</li></ol>\n<p><strong>Step 4:</strong> Right click on the app.js and select the <strong>Open in Command Prompt</strong>. This will open the Node.js command prompt. Enter the following command from the command prompt:</p>\n<p><em>Node app</em></p>\n<p><strong>Step 5:</strong> Open any browser e.g. Chrome, and enter the following URL,</p>\n<p><em><a href=\"http://localhost:5050\">http://localhost:5050</a></em></p>\n<p>A popup prompting the UserName &amp; Password entry will be shown, with an Ok and Cancel Button.</p>\n<p>If the Cancel button is clicked then the following result will be displayed</p>\n<p><strong>Authorization is needed</strong></p>\n<p>Enter UserName as oracle and password as oracle1234 and the following result will be displayed:</p>\n<p><strong>Great You are Autheticated…</strong></p>\n","description":"Authentication plays a very important role in an application. The idea is to access an application, the end-user must enter a username and password. To verify the user, the application should have some mechanism.\nBasic Authentication is a quick way to protect your content. The basic premise of Basic Authentication is that when used over HTTP, the password is sent as plain text. The application intercepts the header information containing Authentication information and validates the username and password by comparing it with the credential information stored at the application side e.g. Database. ","publisherId":"5b4c6b5802ebbd0e1c18646d","createdOn":{"$date":{"$numberLong":"1531883783328"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b4f118070d2974b29af66eb"},"title":"Node js beginner tutorial ","category":"nodejs","content":"","description":"The Essentials\nBefore we begin, you need to have node installed on your computer. I don’t need to write another article on this, so just go here: http://blog.teamtreehouse.com/install-node-js-npm-mac\n\nOpen up your terminal. And navigate to wherever you want to create your project. I have a projects/ folder that I use personally, but it doesn’t matter. Now you need to make a for this project, and in this folder you need to create a file: app.js\n\ncd ~/projects\nmkdir node-blog\ncd node-blog\ntouch app.js\nOkay, I hope I haven’t lost you just yet. Now we need to initialize our project with npm so that we can manage the dependencies that we will be using.\n\nnpm init\nThis will prompt a few questions which will set up your package.json. The only important thing here is that when asked about entry point use: app.js\n\nHere we go\nOkay, now we are ready to start building. To get a webserver up and running fast we will use express. So before writing the code run:\n\nnpm install express@4.16.3 --save\nThis will save the dependency locally so we can use it in our app.\nNow we write some code in app.js\n\n// Setup\nvar express = require('express');\nvar app = express();\n// Listen\napp.listen(3000, () => {\n    console.log('Server listing on 3000');\n})\nWhat this does is the app is set to express() and that app listens on the port specified. In this case 3000. So now when we fire up the app we can view our app on http://localhost:3000\n\nTo start the app, in your terminal run:\n\nnode app.js\nYou should be met with the log: “Server listening on 3000”, which is neat and all but let’s serve up a page so our web app has a view.\n\nFor this tutorial I’ve decided to use the simplest rendering engine that I know of: EJS. You actually can serve static html files if you want to without using an engine, but that would be boring. So follow along and we will have a view up shortly.\n\nIn the terminal:\n\nnpm install ejs --save\nAnd now back in our code we need to add the following lines:\n\napp.engine('html', require('ejs').renderFile);\napp.set('view engine', 'html');\nMake sure you do this below the initialization of app \nNext we need to add a route, to serve the page.\n\napp.get(\"/\", (req, res) => {\n   res.render('index');\n});\nSo this is setting up a route for “/” or the root directory. When this route is hit it will render the index view, which reminds me, we don’t have that yet.\n\nBy default EJS looks for views in a view directory, so let’s create one and lets add an index view while we are at it\n\nmkdir views\ntouch views/index.html\nIn index.html let’s just write up a plain old html file for now, don’t worry we will be adding the dynamic stuff soon enough. In the meantime we will add a form that will post to our app.\n\n<html>\n    <head></head>\n    <body>\n        <h1>Node Blog</h1>\n        <form action=\"addpost\" method=\"POST\">\n            <textarea name=\"body\"></textarea>\n            <input type=\"submit\" value=\"Add Post\" />\n        </form>\n    </body>\n</html>\nAnd just to make sure you are following along, this is what your app.js should look like this:\n\n// Setup\nvar express = require('express');\nvar app = express();\napp.engine('html', require('ejs').renderFile);\napp.set('view engine', 'html');\n// Routes\napp.get(\"/\", (req, res) => {\n   res.render('index');\n});\n// Listen\napp.listen(3000, () => {\n    console.log('Server listing on 3000');\n})\nGo ahead and start the app again now and then visit http://localhost:3000\nIt looks like we are getting somewhere.\n\nNow we need to store the posts from the form. As you can see in index.html our form is posting to “addpost”. So we need to make a route for it and we need to make a schema so that we can store the data when we get it.\n\nWe are going to use mongo for the database. First we are going to install mongo, then we are going to add the data folder where the dbs are stored, then we are going to give that folder the correct permissions. It’s not as hard as it sounds. In your terminal run the following:\n\nbrew install mongo\nmkdir -p /data/db\nsudo chown -R `id -un` /data/db\nThat’s it. Now when we run mongod in the terminal, mongo will be running and ready to use. So actually, go do that now. Open up a separate window and run mongod\n\nWe will be using mongoose to handle our connection to mongo. So in your terminal:\n\nnpm install mongoose --save\nAnd in our app.js:\n\nvar mongoose = require('mongoose')\nmongoose.connect(\"mongodb://localhost:27017/node-blog\")\nNote: mongo by default connects on 27017. The last part of the connection url is the name of our database, here I have decided to use “node-blog”\n\nWhile we are at it we may as well include the body parser so that our application can parse the post data body. We will be using the parsed data to store in our schema. Back in the terminal:\n\nnpm install body-parser\nAnd in our application:\n\nvar bodyParser = require('body-parser')\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true}))\nNow we need to create a schema, and a model for that schema. We do this by creating a new mongoose schema and defining the parameters. Once we have a schema we assign a mongoose model to that schema.\n\nvar postSchema = new mongoose.Schema({ body: String });\nvar Post = mongoose.model('Post', postSchema);\nFinally, we create the “addpost” route that stores this information. We will redirect to our root route when this is complete and we will return an error if necessary.\n\napp.post('/addpost', (req, res) => {\n    var postData = new Post(req.body);\n    postData.save().then( result => {\n        res.redirect('/');\n    }).catch(err => {\n        res.status(400).send(\"Unable to save data\");\n    });\n});\nNow back in our root route we need to grab the data before sending it to the view:\n\napp.get(\"/\", (req, res) => {\n   Post.find({}, (err, posts) => {\n      res.render('index', { posts: posts})\n   });\n});\nWith our data going to our view now, we just have to show the posts that have been saved. We do this using EJS. Back in your index.html:\n\n<html>\n    <head></head>\n    <body>\n        <h1>Node Blog</h1>\n        \n        <% for(let i = 0; i < posts.length; i++) { %>\n            <article>\n                <p><%= posts[i].body %></p>\n            </article>\n        <% } %>\n        <form action=\"addPost\">\n            <textarea name=\"body\"></textarea>\n            <input type=\"submit\" value=\"Add Post\" />\n        </form>\n    </body>\n</html>\nAnd you are done. make sure mongo is running and then run node app.js vistit http://losthost:3000\n\nAnd there you have it. A simple blog built on node, mongo, express and ejs. If you have any issues compare your code to mine below:\n\napp.js\n\n// Setup\nvar express = require('express');\nvar app = express();\nvar mongoose = require('mongoose')\nmongoose.connect(\"mongodb://localhost:27017/node-blog\")\nvar bodyParser = require('body-parser')\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: true}))\napp.engine('html', require('ejs').renderFile);\napp.set('view engine', 'html');\nvar postSchema = new mongoose.Schema({ body: String });\nvar Post = mongoose.model('Post', postSchema);\n// Routes\napp.get(\"/\", (req, res) => {\n   Post.find({}, (err, posts) => {\n      res.render('index', { posts: posts})\n   });\n});\napp.post('/addpost', (req, res) => {\n    var postData = new Post(req.body);\n    postData.save().then( result => {\n        res.redirect('/');\n    }).catch(err => {\n        res.status(400).send(\"Unable to save data\");\n    });\n});\n// Listen\napp.listen(3000, () => {\n    console.log('Server listing on 3000');\n})","publisherId":"5b4759f674c36974d9e84adf","createdOn":{"$date":{"$numberLong":"1531908480331"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b501785f53e9076f99b500a"},"title":"Node.js add-on for Oracle Database","category":"nodejs","content":"<p>The node-oracledb module is open source and maintained by Oracle Corp. It is stable, well documented, and has a comprehensive test suite.<br>Node-oracledb 1.7.0, the Node.js add-on for Oracle Database, is on <a href=\"https://www.npmjs.com/package/oracledb\" title=\"NPM\">NPM</a>.<br>Resources: </p>\n<ul>\n<li><a href=\"https://blogs.oracle.com/opal/node-oracledb-170-has-a-connection-pool-queue-nodejs-add-on-for-oracle-database\">https://blogs.oracle.com/opal/node-oracledb-170-has-a-connection-pool-queue-nodejs-add-on-for-oracle-database</a></li><li><a href=\"https://blogs.oracle.com/opal/node-oracledb-170-has-a-connection-pool-queue-nodejs-add-on-for-oracle-database\">https://blogs.oracle.com/opal/node-oracledb-170-has-a-connection-pool-queue-nodejs-add-on-for-oracle-database</a></li></ul>\n","description":"The node-oracledb add-on for Node.js powers high performance Oracle Database applications.\nUse node-oracledb to connect Node.js 6, 8 and 10 to Oracle Database.\nNode-oracledb supports basic and advanced features of Oracle Database and Oracle Client.","publisherId":"5b4c1c6502ebbd0e1c186462","createdOn":{"$date":{"$numberLong":"1531975557976"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b505c39f53e9076f99b500d"},"title":"Typescript","category":"js","content":"<p>TypeScript is an open-source programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript, and adds optional static typing to the language.</p>\n<p>Typescript gives the compilation error which was not available in the javascript.</p>\n<p>This can be used in nodejs,angular,Oracle jet or any other javascript framework.</p>\n<p>For more information please visit the below links.<br><a href=\"https://en.wikipedia.org/wiki/TypeScript\">https://en.wikipedia.org/wiki/TypeScript</a><br><a href=\"https://www.typescriptlang.org/\">https://www.typescriptlang.org/</a></p>\n","description":"Typescript","publisherId":"5b4828df74c36974d9e84aec","createdOn":{"$date":{"$numberLong":"1531993145684"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b505de9f53e9076f99b500f"},"title":"Promise in Javascript","category":"js","content":"<p>The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.</p>\n<p>A Promise is in one of these states:</p>\n<ul>\n<li>pending: initial state, neither fulfilled nor rejected.</li><li>fulfilled: meaning that the operation completed successfully.</li><li>rejected: meaning that the operation failed.<br>A pending promise can either be fulfilled with a value, or rejected with a reason (error). When either of these options happens, the associated handlers queued up by a promise’s then method are called. (If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.)</li></ul>\n<p>As the Promise.prototype.then() and Promise.prototype.catch() methods return promises, they can be chained.</p>\n<p>For more information please visit the below links.</p>\n<p><a href=\"https://www.sitepoint.com/overview-javascript-promises/\">https://www.sitepoint.com/overview-javascript-promises/</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises</a></p>\n","description":"Use of promise in Javascript","publisherId":"5b4828df74c36974d9e84aec","createdOn":{"$date":{"$numberLong":"1531993577717"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b5060bdf53e9076f99b5010"},"title":"Async/await","category":"js","content":"<p>It is very difficult to work or undertsand promise because of multiple chaining of promise response.</p>\n<p>There’s a special syntax to work with promises in a more comfort fashion, called “async/await”. It’s surprisingly easy to understand and use.</p>\n<h1 id=\"h1-async\"><a name=\"Async\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Async</h1><p>The word “async” before a function means one simple thing: a function always returns a promise. If the code has return &lt;non-promise&gt; in it, then JavaScript automatically wraps it into a resolved promise with that value.async ensures that the function returns a promise, wraps non-promises in it.</p>\n<h1 id=\"h1-await\"><a name=\"Await\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Await</h1><p>The keyword await makes JavaScript wait until that promise settles and returns its result.It can only be used inside async function.</p>\n<p>async function f() {</p>\n<p>  let promise = new Promise((resolve, reject) =&gt; {<br>    setTimeout(() =&gt; resolve(“done!”), 1000)<br>  });</p>\n<p>  let result = await promise; // wait till the promise resolves (*)</p>\n<p>  alert(result); // “done!”<br>}</p>\n<p>f();</p>\n<p>Here result variable will be waiting for the promise to be resolved.</p>\n<p>For more info please visit the below link.<br><a href=\"https://javascript.info/async-await\">https://javascript.info/async-await</a></p>\n","description":"Async/await in javascript","publisherId":"5b4828df74c36974d9e84aec","createdOn":{"$date":{"$numberLong":"1531994301189"}},"__v":{"$numberInt":"0"}}
{"_id":{"$oid":"5b51a3cff53e9076f99b5013"},"title":"Authenticate a Node.js API with JSON Web Tokens","category":"nodejs","content":"","description":"JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.\n\nhttps://scotch.io/tutorials/authenticate-a-node-js-api-with-json-web-tokens\n","publisherId":"5b4874bc74c36974d9e84af9","createdOn":{"$date":{"$numberLong":"1532077007590"}},"__v":{"$numberInt":"0"}}
